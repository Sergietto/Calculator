class ArabicToRome {
    // Преобразует арабское число в римское, с учётом всех нюансов и правил данной системы
    // На вход строка с арабским числом, на выходе - строка с римским числом
    static String convertArabicToRome(String arabicNumber) {
        byte arNumb = Byte.parseByte(arabicNumber);
        if (arNumb < 1) return "Римское число не может быть нулевым или отрицательным!";
        byte romeDigitsArrIndex = 0;    // Тут хранится индекс арабского аналога римской цифры в перечислении всех римских цифр
        String romeNumber = "";
        while (arNumb > 0) {
            byte romeEquivalent = RomeNumber.values()[romeDigitsArrIndex].getValueOfRomeNumber();   // Это подбираемый для римской цифры эквивалент
            if (arNumb >= romeEquivalent) {
                // Все пятирички (числа 5 и 50) - нечётные в рамках объявления в перечислении, если это пятиричка, и в следующей итерации она повторится, то нужно отправляться на вычиталки в блок else
                // Также нужно отправиться на вычиталки, если из трёх текущих эквивалентов цифр не получится число равное или большее арабского, так как превышение количества повторов нарушит правила
                if ((arNumb / romeEquivalent < 4 || isPyatirichkaDieTwice(arNumb, romeEquivalent, romeDigitsArrIndex)) && !((RomeNumber.values()[romeDigitsArrIndex].ordinal() % 2 == 1) && isPyatirichkaDieTwice(arNumb, romeEquivalent, romeDigitsArrIndex))) {
                    // Сюда же попадаем только тогда, количество повторов подряд укладывается в 3
                    arNumb -= romeEquivalent;
                    romeNumber += RomeNumber.values()[romeDigitsArrIndex];
                } else {
                    /*
                    Что тут происходит:
                    1. Ситуация такая - в три повторения подряд не получится сформировать требуемое число, а значит его нужно формировать вычитанием
                    2. Чтобы это сделать, нужно понять из чего вычитать - пока это просто более старшая цифра, если будут беды с пятиричками, то нужно увеличивать, пока не достигнешь кратного десяти
                    3. Далее нужно определиться с тем, что именно вычитаем - это также должна быть цифра кратная 10-ти, либо единица
                    4. С последним вариантом всё просто, а вот десятичную нужно искать: требуется перебрать начиная с меньшего, чем текущий римский эквавалент и до нахождения кратного десяти, дабы не было VX и LC
                    5. Ну а когда находишь вычитатель и вычитаемое нужно сформировать их строковые эквиваленты (причём вычитаемое спереди!), добавить к строчному результату и вычесть из арабского числа
                     */
                    byte subtractorIndex = (byte)(romeDigitsArrIndex - 1);  // Индекс вычитателя
                    byte subtractor = RomeNumber.values()[subtractorIndex].getValueOfRomeNumber();  // Арабское значение вычитателя

                    byte subtrahend = 0;    // Арабское значение вычитаемого
                    byte subtrahendIndex;   // Индекс вычитаемого
                    if (subtractor <= 10) {
                        // Вычитаемое должно быть кратно десяти или единице, следовательно, если вычитатель меньше десяти, то вычитаемое однозначно единица
                        subtrahendIndex = (byte)(RomeNumber.values().length - 1);
                    } else {
                        // Вычитаемое не может быть одинаковым с вычитателем, потому, чтобы не было конфликтов, к индексу вычитателя и добавляем единицу, что выдаст меньшее число
                        subtrahendIndex = (byte) (subtractorIndex + 1);
                        subtrahend = RomeNumber.values()[subtrahendIndex].getValueOfRomeNumber();
                        // Это на случай, если алгоритм захочет сформировать нелегальное LC и ему подобные, уменьшаем вычитаемое, дабы избежать нарушения правил
                        while (subtractor / subtrahend == 2) {
                            subtrahend = RomeNumber.values()[++subtrahendIndex].getValueOfRomeNumber();
                        }
                    }

                    arNumb -= (subtractor - subtrahend);    // Само вычитание из числа с учётом вычитания из вычитателя
                    romeNumber += RomeNumber.values()[subtrahendIndex].toString() + RomeNumber.values()[subtractorIndex].toString();    // Добавление римских аналогов вычитателя и вычитаемого в верном порядке
                }
            } else {
                romeDigitsArrIndex++;   // Не очень, конечно, комфортно, что увеличение индекса, это уменьшение числа, но кто говорил, что я буду писать не ломающий меня же алгоритм
                // Да и вообще изначально мне казалось, что так удобнее))
            }
        }
        return romeNumber;
    }

    // Вернёт истину, если есть проблемы с повторением пятиричек. Sekiro не увлекаюсь, но пока пытался придумать название метода сломал голову об этого босса, потому вот.
    // На вход получает само арабское число, его ближайший римский эквивалент цифры и индекс эквивалента в перечислении римских цифр
    static boolean isPyatirichkaDieTwice(byte arabicNumber, byte romeEquivalent, byte romeDigitIndex) {
        /*
        Что тут происходит:
        Есть данные с текущей итерации, нужно убедиться, что эквивалент, который не должен повторяться (а это все пятирички, они по правилам лишь раз должны встречаться),
            не повторится в следующей итерации. Актуально для девяток, девяносток и т.д., которые без такой проверки весело превращаются в VIV и т.д.
         */
        arabicNumber -= romeEquivalent;         // Уменьшаем число на эквивалент
        byte prevRomeEquivalent = romeEquivalent;   // Запоминаем текущий эквивалент
        // Если эквивалент стал великоват - уменьшаем его
        if (arabicNumber < romeEquivalent) {
            romeEquivalent = RomeNumber.values()[++romeDigitIndex].getValueOfRomeNumber();
        }

        // Например, предыдущий эквивалент был V, текущий стал I. Если это изначально было число 8, то пятиричка здесь физически не повторится, так как можно уложиться в рамках повторяемого эквивалента.
        // Следовательно, в такой ситуации просто говорим, что проблем не предвидится.
        if (arabicNumber / romeEquivalent < 4) {
            return false;
        } else {
            // Но если же изначальное число было девяткой, то окажется, что в 4 "I" мы не можем уложиться, так как это нарушит правила. А что в таких ситуациях делать?
            byte subtractorIndex = (byte)(romeDigitIndex - 1);  // Верно, увеличивать эквивалент и получаеть нужное число вычитанием
            byte subtractor = RomeNumber.values()[subtractorIndex].getValueOfRomeNumber();
            return subtractor == prevRomeEquivalent;  // А если после такого окажется, что предыдущий и текущий вычитатель - это один и тот же эквивалент, значит быть беде
        }
    }
}
